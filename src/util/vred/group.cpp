#include <fstream>

#include "vred.hpp"
#include "group.hpp"
#include "vect.hpp"
#include "input.hpp"


Group::Group(const char* _name, const int _renderStyle, const Color& _color):
  Solid(_name, Vect::null, Vect::null, Vect::unit, _renderStyle, _color), 
  group(new Solid*[GROUP_CHUNK_SIZE]), card(0) 
{
  myBoundingBox.Set(Vect::null,0,0,0,0);
  myBoundingSphere.Set(Vect::null,0);
}

Group::~Group()
{
  if (group != NULL) {
    for (int i=0; i < card; ++i) if (group[i]) delete group[i];
    delete[] group;
  }
}

void Group::Render()
{
  glPushMatrix();
  glMatrixMode(GL_MODELVIEW);
  glMultMatrixd(modelView);
  for (int i=0; i < card; ++i)
    group[i]->Render();
  glPopMatrix();
}

void Group::Add(Solid* const solid)
{
  // check if the solid isn't already in the group
  for (int i=0; i < card; ++i)
    if (group[i] == solid) return;

  // put the solid into the relative ref
  solid->ChangeRef(modelView.Invert());

  // if necessary, augment the size of the group data holder
  if ((card % GROUP_CHUNK_SIZE == 0) && (card != 0)) {
    Solid** _group = new Solid*[card + GROUP_CHUNK_SIZE];
    for (int k=0; k < card; ++k) _group[k] = group[k];
    if (group) delete[] group;
    group = _group;
  }

  // and finally add the solid to the group
  group[card] = solid;
  if (&GetRoot() != this)
    GetRoot().Remove(solid);
  solid->SetFather(this);
  ++card;

  UpdateBoundingVolumes(0);
}

void Group::Remove(Solid* const solid) 
{
  for (int i=0; i < card; ++i)
    if (group[i] == solid) {
      // remove the solid
      group[i] = group[card - 1];
      --card;

      // if necessary, reduce the size of the group data holder
      if ((card % GROUP_CHUNK_SIZE == 0) && (card != GROUP_CHUNK_SIZE) && (card != 0)) {
	Solid** _group = new Solid*[card];
	for (int j=0; j < card; ++j)
	  _group[j] = group[j];
	delete[] group;
	group = _group;
      }

      // put the solid back into the root group
      if (&GetRoot() != this) {
	solid->SetAbsoluteModelView();
	GetRoot().Add(solid);
	//solid->UpdateBoundingVolumes();
      }
    }
  UpdateBoundingVolumes(0);
}

void Group::Explode()
{
  while (card > 0) {
    Remove(group[0]);
  }
}

void Group::SetRenderStyle(const int _renderStyle)
{
  renderStyle = _renderStyle;
  for (int i=0; i < card; ++i)
    group[i]->SetRenderStyle(_renderStyle);
}

void Group::SetColor(const Color& _color)
{
  color = _color;
  for (int i=0; i < card; ++i)
    group[i]->SetColor(_color);
}

void Group::PrintFile(const char *file) const
{
  ofstream out(file, ios::out);
  out << "<!-- File generated by vred -->\n\n" ;
  out << "<vre version=\"7.2\">\n<head>\n<meta name=\"filename\" content=\"" << file << "\"/>\n</head>\n<scene>\n\n" ;
  out << *this;
  out << "</scene>\n</vre>\n" ;
}

int Group::LoadFile(const char *file)
{
  FILE *fp = fopen(file,"r");
  if (fp == NULL) { return (255); }
  int res = LoadFile(fp);
  fclose(fp);
  return res;
}

int Group::LoadFile(FILE *fp)
{
  return FileToGroup(fp, this);
}

int Group::Collide(Solid& moving) const
{
  if (!GetBoundingSphere().Collide(moving.GetBoundingSphere())) return 0;
  if (!GetBoundingBox().Collide(moving.GetBoundingBox())) return 0; 

  for (int i=0; i < GetCard() ; i++) {
    Solid* other=group[i];
    if (other==&moving) continue;
    if (!other->GetBoundingSphere().Collide(moving.GetBoundingSphere())) continue;
    if (!other->GetBoundingBox().Collide(moving.GetBoundingBox())) continue;
    return 1;
  }
  return 0;
}
